写在最前面：感谢贾桐学长给我们留下第一版步兵的代码,和18届学长们从中我学到了非常多的东西

编译环境：
	IDE：
	1 Keilv5  ：直接打开编译完就可以用了
	2 CubeMX 6.3  ：用了CubeMX生成底层配置。
	硬件：
	1 开发板A型 STM32F427IIHx
	2 双板步兵底盘选择开发板C型 STM32F407IGHx
	3 板载IMU(经过严格手动校准后yaw轴基本可以无零飘，频率400hz) 维特wt931陀螺仪，可以回传角度，角速度，角加速度，四元数，且反馈频率能到1000Hz，带宽可调，yaw轴少量零飘。
	软件架构：
	1 STM32Cube FW_F4 V1.24.2
	2 FreeRTOS  ： 跑了操作系统的多进程，方便对代码更改
	3 HAL库 ：挺好用，该有的都有
	

	
代码结构：
	Application/MDK-ARM          :
		startup_stm32f427xx.s ：STM32的启动函数，由ST公司提供
		
	Drivers/STM32F4xx_HAL_Driver : STM32的底层代码，由ST公司提供
	
	Drivers/CMSIS                ：同上
	
	Middlewares/FreeRTOS         : 操作系统代码，CubeMX自动生成，无需人为操作
	
	Application/User             :
		main.c : 主函数，32行添加了头文件，109-124时本人添加的初始化函数，其余皆为CubeMX自动生成，注意如果拆掉操作系统须注掉机器人id检测。
		其他   ：该文件夹下其他所有的c文件均由CubeMX生成
		
	HardWare                     :
		Header.h       : 头文件包含目录
		CRC.c          ：大疆提供的CRC校验文件
		universal.c    : 通用函数，写了一些简单的操作，方便以后开发其他项目的时候直接调用
		bsp_friction.c : 摩擦轮与激光控制函数
		bsp_can.c      : CAN总线过滤器初始化
		bsp_imu.c      : 这对官方开源陀螺仪校准环节进行了修改优化
		bsp_imuex.c    : 外接陀螺仪的接收处理函数
		bsp_uart.c     : 串口的初始化，中断函数，遥控器的接收处理函数也写在这里了
		bsp_TX1.c      : 妙算数据的收发处理
		
	DSP                          ：
		arm_cortexM4lf_math.lib ： ARM提供的DSP数据库
		KalmanFilter.c : 卡尔曼滤波的初始化以及计算函数
		
	Task                         :
		Config.h       : 机器人一些参数的设置
		start_task.c   : 创建任务进程，用户数据初始化
		detect_task.c  : 检测设备是否在线，处理低频率任务，如TX1数据的发送
		gimbal_task.c  : 云台的操作任务
		chassis_task.c ： 底盘的操作任务
		remote_task.c  ： 遥控器的操作任务
                                cap_task.c  ： 电容的的操作任务
                                user_task.c  ： UI的操作任务
		referee.c      ：裁判系统的接收处理函数
		pid.c          : pid控制器
                                adrc.c          : adrc控制器
                                filter.c           ：一些常用滤波器
		powerlimit.c   : 功率限制
		can_receive.c  ：电机反馈数据的处理

                                uart1接收遥控器数据，uart3接收miniPC数据，uart6接收裁判系统数据，uart8接收外接陀螺仪数据

云台控制：
               控制难点集中在pitch轴，因机械问题，云台设计不太可能使转轴位于负载中心，所以首先对云台进行重力矩补偿，补偿输出=T*costheta。
               因为can对6020电调输出为电压值，所以加入转矩闭环（注意can读回的数为相反数），最终控制器为位置-速度-转矩三环。因位置环和速度
               环受到编码器精度影响，可以使用卡尔曼滤波对编码器数据进行滤波，可以直接使用滤波后数据进行控制（效果有待商榷，有钱最好上陀螺仪），
               同时为了控制效果，用二阶adrc控制器代替PID位置环，目前效果挺好

UI界面
               已对写法进行整理简化，直接用user.c里的函数就可以了，注意发送帧率不能太高，最好别超30hz
		
裁判系统数据的接收 （还是延用桐哥的）
               裁判系统的数据为不定长数据，官方开源里的解决方案是串口空闲DMA中断，本人采用的是DMA中断接收的，具体思路如下：
               反馈的数据分为四部分：帧头、命令码、数据、CRC校验，本人将其分为两部分接收：
               第一部分：帧头与命令码（固定7字节）
               第二部分：数据与CRC校验（字节长度不固定，但是帧头的信息里提到了数据帧的长度，故该长度为已知）
               处理逻辑：1、设置串口DMA接收，缓冲区长度为7帧，等待接收。
		2、触发中断，关闭DMA，根据帧头里的数据帧长度，修改DMA缓冲区长度，打开DMA。
		3、等待第二部分数据触发中断，关闭DMA，对数据进行处理，修改缓冲区长度为7，打开DMA。
		4、重复以上步骤
								  
功率控制
             对功率值进行闭环控制，期望值为裁判系统读取的数据，反馈值为实时功率，输出值为轮子最大转速。
	
	
	
云台建模与自动整定PID参数 ：参考桐哥的文档
卡尔曼滤波：个人觉得作用在于对miniPC数据进行补帧，并且结合建立的匀速模型进行预测（加上加速度感觉没多大用），主要调整QR矩阵的值
					

                                                                                                                                                                                                          BJUT 张曦梁
